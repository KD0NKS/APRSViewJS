var AbstractPacketParser = require('./AbstractPacketParser.js')
	, AbstractAPRSMessage = require('../../packets/AbstractAPRSMessage.js')
	, APRSPositionReport = require('../../packets/APRSPositionReport.js')
	, APRSMessage = require('../../packets/APRSMessage.js')
	, ObjectReport = require('../../packets/ObjectReport.js')
	;

function AGWPEPacketParser() {
	AbstractPacketParser.apply(this, arguments);
}

AGWPEPacketParser.prototype = new AbstractPacketParser();
AGWPEPacketParser.prototype.constructor = AGWPEPacketParser;

//Main public parsing function
AGWPEPacketParser.prototype.parse = function(packet) {
	if(packet.length > 35) {
		var dataType = String.fromCharCode(packet[4])
		
        /*
		var header = packet.slice(36).toString('utf8').trim();
		var body = header.slice(header.indexOf('\r') + 1).trim();
        header.replace(/\r/g, '');
		header = header.slice(0, header.indexOf('\r')).trim();
        */
        
        var header = packet.toString('utf8', 36, packet.length);
        header = header.trim();
        var body = header.slice(header.indexOf('\r') + 1).trim();
        header = header.slice(0, header.indexOf('\r')).trim();
        
        body = body.replace(/\0/g, ' ');
        body = body.replace(/\r/g, ' ');
        
        body = body.trim();
        
        var report = null;
		
		// read the packet data
		if(body.length > 0) {
			if(dataType == 'R') { // Version
				//frameData = new AgwpeVersion(data);
			} else if(dataType == 'X') { // Callsign Registration
				/*
				if (data[0] == 1)
					frameData = true;
				else
					frameData = false;
				*/
			} else if(dataType == 'G') { // Port Information
				//frameData = new AgwpePortInfo(data, frameHeader.DataLen);
			} else if(dataType == 'g') { // Port Capability
				//frameData = new AgwpePortCapability(data);
			} else if(dataType == 'y' || dataType == 'Y') {
				// 'y' : Frames Outstanding on a Port
				// 'Y': Frames Outstanding on a Connection
				//frameData = System.BitConverter.ToUInt32(data, 0);
			} else if(dataType == 'H') { // Stations Heard on a Port
				//frameData = new AgwpeStationsHeard(data, frameHeader.DataLen);
			} else if(dataType == 'C' || dataType == 'c' || dataType == 'v') {
				// 'C': AX.25 Connection Received
				// 'c': Non-Standard AX.25 Connection Received
				// 'v': AX.25 Connection Using Digipeaters Received
				//frameData = new AgwpeAX25Connect(data, frameHeader.DataLen);
			} else if(dataType == 'd' || dataType == 'D' || dataType == 'S' || dataType == 'K') { //dataType == 'T'|| 
				// 'd': AX.25 Disconnect Received
				// 'D': AX.25 Connection Data
				// 'S': Monitored Supervisory Information
				// 'T': Monitoring Own Information
				// 'K': Monitored Information in Raw Format
				//frameData = new AgwpeAX25Data(data, frameHeader.DataLen);
                console.log(packet.toString('utf8'));
			} else if(dataType == 'I') { // Monitored Connected Information
				//frameData = new AgwpeMoniConnInfo(data, frameHeader.DataLen);
			} else if(dataType == 'U' || dataType == 'T') { // Monitored Unproto Information
				if(body.charAt(0) == '>') {
					if(body.charAt(6).toLowerCase() == "z") {
						this.extractTimeStamp(report, body);
					}
					
					report = new AbstractAPRSMessage();
					
					body = this.extractCommonFields(report, header, body, packet);
					this.extractStatusReport(report, body);
				} else if(body.indexOf("$GPGGA,") == 0) {     // Is this a GPGGA packet?
					//packet = ParseGppaPacket(packet, line);
					throw new Error(this.Messages.unknown);
				} else if(body.charAt(0) == '`'
						|| body.charAt(0) == '\'') {
					report = new APRSPositionReport();
					
					body = this.extractCommonFields(report, header, body, packet);
					body = this.extractMicE(report, body);
					
					report.isIconRotatable = this.isIconRotatable(report.symbolTableId, report.symbolCode, report.speed, report.direction);
				} else if(body.charAt(0) == '='
						|| body.charAt(0) == '!'
						|| body.charAt(0) == '@'
						|| body.charAt(0) == '/') {   // Is this a location/weather location packet?
					report = new APRSPositionReport();
					
					body = this.extractCommonFields(report, header, body, packet);
					
					// check to see if the packet contains a timestamp before the coordinates
					if(body.charAt(0) == '/' || body.charAt(0) == '@') {
						body = this.extractTimeStamp(report, body.substring(1));
					}
					
					body = this.extractPosition(report, body);
					
					report.isIconRotatable = this.isIconRotatable(report.symbolTableId, report.symbolCode, report.speed, report.direction);
				} else if(body.charAt(0) == '_') {    // Is this packet a Positionless Weather Report?
					//packet = ParsePositionlessWeatherPacket(packet, line);
					throw new Error(this.Messages.unknown);
				} else if(body.charAt(0) == 'T') {    //"T" Telemetry data - bodyBytes.Length > 18
					//throw new UnsupportedFormatAprsPacketException("Telemetry packets are not yet supported.");
					throw new Error(this.Messages.unknown);
				} else if(body.charAt(0) == ')') {    //")" Item - bodyBytes.Length > 18
					//throw new UnsupportedFormatAprsPacketException("Item packets are not yet supported.");
					throw new Error(this.Messages.unknown);
				} else if(body.charAt(0) == ';') {    //";" Object - bodyBytes.Length > 29
					report = new ObjectReport();
					
					body = this.extractCommonFields(report, header, body, packet);
					
					report.name = body.substr(0, 9).trim();
					
					// * indicates a live object
					// _ indicates a killed object
					report.indicator = body.charAt(9);
					
					body = this.extractTimeStamp(report, body.substring(10));
					
					if(body.charAt(0) == '/') { // assume compressed format
						console.log('OBJECT POSITION IN COMPRESSED FORMAT');
						throw new Error(this.Messages.unknown);
					} else { // lat/lng format
						body = this.extractPosition(report, body);
					}
					
					report.isIconRotatable = this.isIconRotatable(report.symbolTableId, report.symbolCode, report.speed, report.direction);
				} else if(body.charAt(0) == '}') {    //"}" Third-party traffic
					// TODO: CAN WE ASSUME THIS WILL ALWAYS BE APRS SPEC FORMAT?
					//AprsPacketParser parser = new AprsPacketParser();
					//packet = parser.ParseAprsPacket(line.Substring(1));
					throw new Error(this.Messages.unknown);
				} else if(body.charAt(0) == ':') {
					report = new APRSMessage();
					
					body = this.extractCommonFields(report, header, body, packet);
					
					this.extractMessage(report, body);
				} else {
					console.log(packet.toString('utf8'));
					
					throw new Error(this.Messages.unknown);
				}

				//  UNSUPPORTED
				// '0x1c' !whitespace char ''! Current Mic-E Data (Rev 0 beta)
				// '0x1d' !whitespace char ''! Old Mic-E Data (Rev 0 beta)
				// '&' [Reserved — Map Feature]
				// '['Reserved — Shelter data with time]
				// '{' User-Defined APRS packet format
				// '.' [Reserved — Space weather]
				// "%" Agrelo DFJr / MicroFinder
				// "," Invalid data or test data
				// "#" Peet Bros U-II Weather Station
				// "$" Raw GPS data or Ultimeter 2000
				// "$ULTW"
				// "*" Peet Bros U-II Weather Station
				// else if(line.IndexOf(":<") > -1) {    // "<" Station Capabilities
				// else if(line.IndexOf("::") > -1) {    //":" Message 
				// else if(line.IndexOf(":?") > -1) {    //"?" Query

				// WILL NOT USE
				//"[" Maidenhead grid locator beacon (obsolete)

				// UNUSED
				//'"' [Unused] 
				//'(' [Unused] 
				//'\' [Unused]
				//']' [Unused]
				//'^' [Unused]
				//'-' [Unused] 

				// DO NOT USE
				//'0–9' [Do not use] 
				//'a–z' [Do not use]
				//'A–S' [Do not use]
				//'U–Z' [Do not use]
				//'~' [Do not use — TNC stream switch character]
				//"|" [Do not use — TNC stream switch character]
				
				return report;
			}
		
			/*
			case RD_PKT_DATA: // Reading incoming packet data
				if (dataLen > 0)
				{
					dataByte = stream.ReadByte();
					if (dataByte >= 0)
					{
						dataBuffer.AddByte((byte)dataByte);
						--dataLen;
						if (dataLen == 0)
						{
							state = STANDBY;
							if (dataBuffer.Count >= BitConverter.ToUInt32(frameBuffer, 28))
								if (header != null & header.Length == 36)
								{
									this.header = new byte[36];
									header.CopyTo(this.header, 0);
								}

								if (data != null & data.Length > 0)
								{
									this.data = new byte[data.Length];
									data.CopyTo(this.data, 0);
								}

								frameHeader = new AgwpeHeader(header);

								if (frameHeader.DataLen > 0 & data.GetLength(0) >= frameHeader.DataLen)
								{
									switch (frameHeader.DataKind)
									{
										
									}
								}
								else
									this.frameData = null;
						}
					}
				}
			*/
		}
	}
}

AGWPEPacketParser.prototype.extractCommonFields = function(report, header, body, packet) {
	report.receivedTime = new Date();
	
	//Store the raw packet in the position report object
	report.rawPacket = packet.toString('utf8');
	
	//Extract the callsign from the packet
	this.extractCallsign(report, header);
	
	this.extractDestinationAndDigipeaters(report, header);
	
	// Extract the message type
	body = this.extractMessageType(report, body);
	
	return body;
}

//Retrieve the station's callsign from the raw packet
AGWPEPacketParser.prototype.extractCallsign = function(report, header) {
	report.callsign = header.slice(header.indexOf('Fm ') + 3, header.indexOf(' To')).trim();
}

AGWPEPacketParser.prototype.extractDestinationAndDigipeaters = function(report, header) {
	try {
		report.destination = header.slice(header.indexOf('To ') + 3, header.indexOf(' Via')).trim();
		report.digipeaters = header.slice(header.indexOf('Via') + 3, header.indexOf('<')).trim().split(',');
	} catch (e) { }
}

module.exports = AGWPEPacketParser;