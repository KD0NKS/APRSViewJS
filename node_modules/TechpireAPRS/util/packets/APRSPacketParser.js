var AbstractAPRSMessage = require('../../packets/AbstractAPRSMessage.js');
var APRSPositionReport = require('../../packets/APRSPositionReport.js');
var APRSMessage = require('../../packets/APRSMessage.js');

module.exports = function APRSPacketParser() {
	//Main public parsing function
	this.parse = function(packet) {
		var header = packet.split(':')[0];
		
		var body = body = packet.substring(packet.indexOf(':') + 1);
		
		var report = null;
		
		try {
			if(body.charAt(0) == '>') {
				if(body.charAt(6).toLowerCase() == "z") {
					this.extractTimeStamp(report, body);
				}
				
				report = new AbstractAPRSMessage();
				
				body = this.extractCommonFields(report, header, body, packet);
				this.extractStatusReport(report, body);
			} else if(body.indexOf("$GPGGA,") == 0) {     // Is this a GPGGA packet?
				//packet = ParseGppaPacket(packet, line);
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == '`'
					|| body.charAt(0) == '\'') {
				report = new APRSPositionReport();
				
				body = this.extractCommonFields(report, header, body, packet);
				body = this.extractMicE(report, body);
				
				report.isIconRotatable = this.isIconRotatable(report.symbolTableId, report.symbolCode, report.speed, report.direction);
			} else if(body.charAt(0) == '='
					|| body.charAt(0) == '!'
					|| body.charAt(0) == '@'
					|| body.charAt(0) == '/') {   // Is this a location/weather location packet?
				report = new APRSPositionReport();
				
				body = this.extractCommonFields(report, header, body, packet);
				
				// check to see if the packet contains a timestamp before the coordinates
				if(body.charAt(0) == '/' || body.charAt(0) == '@') {
					body = this.extractTimeStamp(report, body);
				}
				
				body = this.extractPosition(report, body);
				
				report.isIconRotatable = this.isIconRotatable(report.symbolTableId, report.symbolCode, report.speed, report.direction);
			} else if(body.charAt(0) == '_') {    // Is this packet a Positionless Weather Report?
				//packet = ParsePositionlessWeatherPacket(packet, line);
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == 'T') {    //"T" Telemetry data - bodyBytes.Length > 18
				//throw new UnsupportedFormatAprsPacketException("Telemetry packets are not yet supported.");
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == ')') {    //")" Item - bodyBytes.Length > 18
				//throw new UnsupportedFormatAprsPacketException("Item packets are not yet supported.");
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == ';') {    //";" Object - bodyBytes.Length > 29
				//throw new UnsupportedFormatAprsPacketException("Object packets are not yet supported.");
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == '}') {    //"}" Third-party traffic
				// TODO: CAN WE ASSUME THIS WILL ALWAYS BE APRS SPEC FORMAT?
				//AprsPacketParser parser = new AprsPacketParser();
				//packet = parser.ParseAprsPacket(line.Substring(1));
				throw new Error(this.Messages.unknown);
			} else if(body.charAt(0) == ':') {
				// We can do this since it's not really abstract.
				report = new APRSMessage();
				
				body = this.extractCommonFields(report, header, body, packet);
				
				this.extractMessage(report, body);
			} else {
				throw new Error(this.Messages.unknown);
			}

			//  UNSUPPORTED
			// '0x1c' !whitespace char ''! Current Mic-E Data (Rev 0 beta)
			// '0x1d' !whitespace char ''! Old Mic-E Data (Rev 0 beta)
			// '&' [Reserved — Map Feature]
			// '['Reserved — Shelter data with time]
			// '{' User-Defined APRS packet format
			// '.' [Reserved — Space weather]
			// "%" Agrelo DFJr / MicroFinder
			// "," Invalid data or test data
			// "#" Peet Bros U-II Weather Station
			// "$" Raw GPS data or Ultimeter 2000
			// "$ULTW"
			// "*" Peet Bros U-II Weather Station
			// else if(line.IndexOf(":<") > -1) {    // "<" Station Capabilities
			// else if(line.IndexOf("::") > -1) {    //":" Message 
			// else if(line.IndexOf(":?") > -1) {    //"?" Query

			// WILL NOT USE
			//"[" Maidenhead grid locator beacon (obsolete)

			// UNUSED
			//'"' [Unused] 
			//'(' [Unused] 
			//'\' [Unused]
			//']' [Unused]
			//'^' [Unused]
			//'-' [Unused] 

			// DO NOT USE
			//'0–9' [Do not use] 
			//'a–z' [Do not use]
			//'A–S' [Do not use]
			//'U–Z' [Do not use]
			//'~' [Do not use — TNC stream switch character]
			//"|" [Do not use — TNC stream switch character]
			
			
			
			return report;
		} catch(e) {
			throw(e);
		}
	}
	
	this.extractCommonFields = function(report, header, body, packet) {
		report.receivedTime = new Date();
		
		//Store the raw packet in the position report object
		report.rawPacket = packet;
		
		//Extract the callsign from the packet
		header = this.extractCallsign(report, header);
		
		this.extractDestinationAndDigipeaters(report, header);
		
		// Extract the message type
		body = this.extractMessageType(report, body);
		
		return body;
	}
	
	//Retrieve the station's callsign from the raw packet
	this.extractCallsign = function (report, header) {
		report.callsign = header.split(">")[0];
		
		return header.split(">")[1];
	}
	
	//Retrieve the message section from the raw packet
	this.extractDestinationAndDigipeaters = function(report, header) {
		try {
			report.destination = header.split(',')[0];
			report.digipeaters = header.split(',');
		} catch (e) { }
	}
	
	// Extract the message type
	this.extractMessageType = function(report, body) {
		report.messageType = body.charAt(0);
		return body.substring(1);
	}
	
	//Extract the latitude/longitude from the raw packet
	this.extractPosition = function(report, body) {
		try {
			if(/^[0-9 ]{4}\.[0-9 ]{2}/.test(body)) {
				var txtLat = body.substring(0, 8);
				
				report.symbolTableId = body.charAt(8);
				
				report.positionAmbiguity = txtLat.split(' ').length - 1;
				
				var latDegrees = parseFloat( txtLat.substr(0,2) );
				var latMinutes = parseFloat( txtLat.substr(2,5) );
				
				report.latitude = latDegrees + (latMinutes / 60);
				report.parallel = txtLat.charAt(txtLat.length - 1);
				
				if( report.parallel.toUpperCase() == "S" ) {
					report.latitude = report.latitude * -1;
				};
				
				body = body.substring(9);
				report.symbolCode = body.charAt(9);
				
				var txtLon = body.substring(0, 9).replace(' ', '0');
				report.meridian = txtLon.charAt(8);
				
				var lonDegrees = parseInt( txtLon.substr(0,3) );
				var lonMinutes = parseFloat( txtLon.substr(3,5) ) / 60;
				
				report.longitude = parseFloat(txtLon.substr(0,3) + lonMinutes.toString().substring(1));
				
				if( report.meridian.toUpperCase() == "W") {
					report.longitude = report.longitude * -1;
				};
				
				body = body.substring(10);
			}
			
			return body;
		} catch (e) {
			report.latitude = null;
			report.longitude = null;	
		
			throw(e);
		}
	}
	
	this.extractMicE = function(report, body) {
		if(report.destination == null || report.destination == '') {
			throw new Error("Error in parsing Mic-E packet.  Destination field was empty.");
		}
		
		var destinationArray = unescape(encodeURIComponent(report.destination));
		var informationArray = unescape(encodeURIComponent(body));
		
		// Latitude
		var degLatitude = (destinationArray.charCodeAt(0) & 0x0F).toString() + (destinationArray.charCodeAt(1) & 0x0F).toString();
		var degLatMin = (parseFloat((destinationArray.charCodeAt(2) & 0x0F).toString() + (destinationArray.charCodeAt(3) & 0x0F).toString()
				+ "." + (destinationArray.charCodeAt(4) & 0x0F).toString() + (destinationArray.charCodeAt(5) & 0x0F).toString()) / 60).toString();
		
		report.latitude = parseFloat(degLatitude + degLatMin.substring(1)).toFixed(3);
		report.latitude = parseFloat(report.latitude);
		
		if(destinationArray.charCodeAt(3) < 80) {
			report.latitude = report.latitude * -1;
		}
		
		// Longitude
		// L-Bit is contained in Destination Array as the 5th byte.
		// On Page 44 of the APRS 1.0 spec is where this is defined.
		// The offset is 100 for anything above 'P' (int val 80).
		var longitudeOffset = 0;
		
		if(destinationArray.charCodeAt(4) >= 80) {
			longitudeOffset = 100;
		}
		
		var degLongitude = informationArray.charCodeAt(0) - 28 + longitudeOffset;
		
		if((degLongitude >= 180) && (degLongitude <= 189)) {
			degLongitude -= 80;
		}

		if((degLongitude >= 190) && (degLongitude <= 199)) {
			degLongitude = degLongitude  - 190;
		}
		
		var degLonMin = informationArray.charCodeAt(1) - 28;
		
		if(degLonMin >= 60) {
			degLonMin = degLonMin - 60;
		}
		
		degLonMin = parseFloat(degLonMin + "." + (informationArray.charCodeAt(2) - 28)) / 60;
		
		report.longitude = parseFloat(degLongitude.toString() + degLonMin.toString().substring(1)).toFixed(3);
		
		if(destinationArray.charCodeAt(5) >= 80) {
			report.longitude = report.longitude * -1;
		}
		
		// SYMBOL
		report.symbolTableId = String.fromCharCode(informationArray.charCodeAt(7));
		report.symbolCode = String.fromCharCode(informationArray.charCodeAt(6));
		
		// STATION SPEED IN KNOTS
		report.speed = informationArray.charCodeAt(3) - 28;

		// this is taken from p 53 of the APRS 1.01 Spec
		if(report.speed >= 80) {
			report.speed -= 80;
		}

		report.speed = ((report.speed * 10) + ((informationArray.charCodeAt(4) - 28) / 10) % 800);
		
		// COURSE MUST BE IN INT FORM
		report.direction = ((informationArray.charCodeAt(4) - 28) % 10) * 100;
		report.direction = report.direction +(informationArray.charCodeAt(5) - 28);
		report.direction = report.direction % 400;
		
		// TODO: Position ambiguity.
		// TODO: ALTITUDE
		
		return body;
	}
	
	//Create a timestamp from the time in the raw packet if one exists
	this.extractTimeStamp = function(report, body) {
		var ts = new Date();

		try {
			var message = report.message;

			if (report.messageType == '@') {
				/*
				* There are 3 different time formats that can be used
				* We are only dealing with Day/Hour/Minutes in either
				* zulu or local time (not with month/day/hour/minute)
				*/
				//Day/Hours/Minutes
				if (message.charAt(7) == 'z') {
					ts.setUTCDate(parseInt(message.substr(1, 2)));
					ts.setUTCHours(parseInt(message.substr(3, 2)));
					ts.setUTCMinutes(parseInt(message.substr(5, 2)));
					ts.setUTCMilliseconds(0);
					
					body = body.substring(8);
				} else if (message.charAt(6) == 'l') {
					ts.setDate(parseInt(message.substr(1, 2)));
					ts.setHours(parseInt(message.substr(3, 2)));
					ts.setMinutes(parseInt(message.substr(5, 2)));
					ts.setMilliseconds(0);
					
					body = body.substring(7);
				}
			}
		} catch (e) { }
		
		report.gpsTimestamp = ts;
		
		return body;
	}
	
	/*
	//Extract the altitude from the raw packet if one exists
	this.extractAltitude = function(report) {
		try {
			var startAlt = report.message.indexOf("/A=");
			
			if(startAlt > 0) {
				var txtAlt = report.message.substr(startAlt + 3, 6);
				report.altitude = parseInt(txtAlt, 10);
			}
		} catch (e) { }
	}

	//Parsing messages setup and retrieval

	this.getMessage = function(msgName){
		return this.Messages[ msgName ];
	}
	*/
	
	
	
	this.extractMessage = function(report, body) {
		if(body.indexOf("BLN") == 0) {
			report.addressee = "BLN";
			report.number = body[3];
			report.addressee = body.substring(4, 5)
			report.message = body.split(':')[1];
		} else if(body.indexOf("NWS") == 0) {
			report.addressee = body.split(':')[0];
			report.message = body.split(':')[1];
		} else {
			report.addressee = body.split(':')[0];
			
			if(body.indexOf('{') > -1) {
				report.message = body.split(':')[1];
				//report.MessageText = line.substring(10, (line.indexOf('{') - 11));
				//report.MessageId = line.substring(line.indexOf('{') + 1);
			} else {
				report.message = body.split(':')[1];
				// this can be a plain message, ack or reject
				//report.MessageText = line.substring(10);
			}
		}
		
		return report;
	}
	
	this.extractStatusReport = function(report, body) {
		// todo: if the report has a timestamp body.length > 55 it's an invalid method, throw an error?
		// otherwise the body.length > 62 should throw an error?
		
		report.message = body;
	}
	
	this.isIconRotatable = function(symbolTableId, symbolCode, speed, direction) {
		if(direction != null && direction != '' && direction != "..." && speed != null && speed != '' && speed != "...") {
			if(symbolTableId == '/' && (
					symbolCode == '\'' || symbolCode == '(' || symbolCode == '*' || symbolCode == '<'
					|| symbolCode == '=' || symbolCode == '>' || symbolCode == 'C' || symbolCode == 'F'
					|| symbolCode == 'O' || symbolCode == 'P' || symbolCode == 'S' || symbolCode == 'U'
					|| symbolCode == 'X' || symbolCode == 'Y' || symbolCode == '[' || symbolCode == '^'
					|| symbolCode == 'a' || symbolCode == 'b' || symbolCode == 'e' || symbolCode == 'f'
					|| symbolCode == 'g' || symbolCode == 'j' || symbolCode == 'k' || symbolCode == 'p' 
					|| symbolCode == 's' || symbolCode == 'u' || symbolCode == 'v')) {
				return true;
			} else if((symbolTableId == '\\' || (/[A-Z0-9]/.test(symbolTableId))) && (
					symbolCode == '>' || symbolCode == 'O' || symbolCode == 'S' || symbolCode == '^'
					|| symbolCode == 'k' || symbolCode == 's' || symbolCode == 'u' || symbolCode == 'v')) {
				return true
			} else {
				return false;
			}
		} else {
			return false;
		}
		
		
		return false;
	}
	
	
	
	this.InitializeMessages = function() {
		var Messages = new Object();

		Messages.unknown = 'Unsupported packet format';

		Messages.packet_no = 'No packet given to parse';
		Messages.packet_short = 'Too short packet';
		Messages.packet_nobody = 'No body in packet';

		Messages.srccall_noax25 = 'Source callsign is not a valid AX.25 call';
		Messages.srccall_badchars = 'Source callsign contains bad characters';

		Messages.dstpath_toomany = 'Too many destination path components to be AX.25';
		Messages.dstcall_none = 'No destination field in packet';
		Messages.dstcall_noax25 = 'Destination callsign is not a valid AX.25 call';

		Messages.digicall_noax25 = 'Digipeater callsign is not a valid AX.25 call';
		Messages.digicall_badchars = 'Digipeater callsign contains bad characters';

		Messages.timestamp_inv_loc = 'Invalid timestamp in location';
		Messages.timestamp_inv_obj = 'Invalid timestamp in object';
		Messages.timestamp_inv_sta = 'Invalid timestamp in status';
		Messages.timestamp_inv_gpgga = 'Invalid timestamp in GPGGA sentence';
		Messages.timestamp_inv_gpgll = 'Invalid timestamp in GPGLL sentence';

		Messages.packet_invalid = 'Invalid packet';

		Messages.nmea_inv_cval = 'Invalid coordinate value in NMEA sentence';
		Messages.nmea_large_ew = 'Too large value in NMEA sentence (east/west)';
		Messages.nmea_large_ns = 'Too large value in NMEA sentence (north/south)';
		Messages.nmea_inv_sign = 'Invalid lat/long sign in NMEA sentence';
		Messages.nmea_inv_cksum = 'Invalid checksum in NMEA sentence';

		Messages.gprmc_fewfields = 'Less than ten fields in GPRMC sentence ';
		Messages.gprmc_nofix = 'No GPS fix in GPRMC sentence';
		Messages.gprmc_inv_time = 'Invalid timestamp in GPRMC sentence';
		Messages.gprmc_inv_date = 'Invalid date in GPRMC sentence';
		Messages.gprmc_date_out = 'GPRMC date does not fit in an Unix timestamp';

		Messages.gpgga_fewfields = 'Less than 11 fields in GPGGA sentence';
		Messages.gpgga_nofix = 'No GPS fix in GPGGA sentence';

		Messages.gpgll_fewfields = 'Less than 5 fields in GPGLL sentence';
		Messages.gpgll_nofix = 'No GPS fix in GPGLL sentence';

		Messages.nmea_unsupp = 'Unsupported NMEA sentence type';

		Messages.obj_short = 'Too short object';
		Messages.obj_inv = 'Invalid object';
		Messages.obj_dec_err = 'Error in object location decoding';

		Messages.item_short = 'Too short item';
		Messages.item_inv = 'Invalid item';
		Messages.item_dec_err = 'Error in item location decoding';

		Messages.loc_short = 'Too short uncompressed location';
		Messages.loc_inv = 'Invalid uncompressed location';
		Messages.loc_large = 'Degree value too large';
		Messages.loc_amb_inv = 'Invalid position ambiguity';

		Messages.mice_short = 'Too short mic-e packet';
		Messages.mice_inv = 'Invalid characters in mic-e packet';
		Messages.mice_inv_info = 'Invalid characters in mic-e information field';
		Messages.mice_amb_large = 'Too much position ambiguity in mic-e packet';
		Messages.mice_amb_inv = 'Invalid position ambiguity in mic-e packet';
		Messages.mice_amb_odd = 'Odd position ambiguity in mic-e packet';

		Messages.comp_inv = 'Invalid compressed packet';

		Messages.msg_inv = 'Invalid message packet';

		Messages.wx_unsupp = 'Unsupported weather format';
		Messages.user_unsupp = 'Unsupported user format';

		Messages.dx_inv_src = 'Invalid DX spot source callsign';
		Messages.dx_inf_freq = 'Invalid DX spot frequency';
		Messages.dx_no_dx = 'No DX spot callsign found';

		Messages.tlm_inv = 'Invalid telemetry packet';
		Messages.tlm_large = 'Too large telemetry value';
		Messages.tlm_unsupp = 'Unsupported telemetry';

		Messages.exp_unsupp = 'Unsupported experimental';

		Messages.sym_inv_table = 'Invalid symbol table or overlay';

		this.Messages = Messages;
	}

	this.InitializeMessages();
}