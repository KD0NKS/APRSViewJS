var util = require('util')
	, net = require('net')
	, EventEmitter = require('events').EventEmitter
	, AbstractDataConnection = require('./AbstractDataConnection.js')
	, APRSPacketParser = require('../util/packets/APRSPacketParser.js')
    , AbstractAPRSMessage = require('../packets/AbstractAPRSMessage.js')
    , APRSPositionReport = require('../packets/APRSPositionReport.js')
    , APRSMessage = require('../packets/APRSMessage.js')
    , ISPacketConverter = require('../util/packets/ISPacketConverter.js')
	;

var MESSAGE_DELIMITER = '\r\n';

function JavAPRSISConnection(args) {
	var instance = this;
    
    instance.packetConverter = new ISPacketConverter();

	// TODO: Set defaults
	if(!args) {
		return;
	}
	
	instance.passcode = args.passcode;
	instance.filter = args.filter;
	
	// RESETTING AN INTERVAL EVERY TIME A MESSAGE IS RECEIVED IS EXTREMELY INEFFICIENT.  COME UP WITH SOMETHING BETTER.
	instance.keepAliveTime = null;
	
	if(args.keepAliveTime != null && args.keepAliveTime != undefined && args.keepAliveTime > 0) {
		instance.keepAliveTime = args.keepAliveTime;
		instance.keepAlive = setInterval(instance.SendLogin, instance.keepAliveTime);
	} else {
        // default to 60000
        instance.keepAlive = setInterval(instance.SendLogin, 60000);   
    }
	
	AbstractDataConnection.apply(instance, arguments);
    	
	return instance;
}

JavAPRSISConnection.prototype = new AbstractDataConnection();
JavAPRSISConnection.prototype.constructor = JavAPRSISConnection;

// http://phrogz.net/JS/classes/OOPinJS2.html
JavAPRSISConnection.prototype.parent = AbstractDataConnection.prototype;

JavAPRSISConnection.prototype.Read = function() {
    var instance = this;
    
	// when you get into socket.on, this takes on the socket scope not the JavAPRSISConnection scope
    instance.parent.Read.call(instance);
    
	try {
		var parser = new APRSPacketParser();
		
		instance.socket.on('data', function(data) {
			var packets = data.toString().split('\r\n');
			
			for(var x = 0; x < packets.length && packets[x] != ''; x++) {
				if(packets[x].toString()[0] != '#') {
					// parse the packet
					try {
						var rpt = parser.parse(packets[x]);
						
						// finding the message type in a nested if statement seems to be faster than storing the message types in an array to reduce the code
						if(rpt.messageType == '>') {
							// status report
						} else if(rpt.messageType == "$GPGGA,") {
							// GPPA
						} else if(rpt.messageType == '`'
								|| rpt.messageType == '\'') {
							// mic-e
							instance.emit('position', rpt);
						} else if(rpt.messageType == '='
								|| rpt.messageType == '!'
								|| rpt.messageType == '@'
								|| rpt.messageType == '/') {
							// position report
							instance.emit('position', rpt);
						} else if(rpt.messageType == '_') {
							// positionless weather report
						} else if(rpt.messageType == 'T') {
							// telemetry data
						} else if(rpt.messageType == ')') {
							//")" Item - bodyBytes.Length > 18
						} else if(rpt.messageType == ';') {
							//";" Object - bodyBytes.Length > 29
							instance.emit('object', rpt);
						} else if(rpt.messageType == '}') {
							//"}" Third-party traffic
						} else if(rpt.messageType == ':') {
                            instance.emit('message', rpt);
                            
							// message
                            if(rpt.addressee.toUpperCase() == instance.callsign.toUpperCase() && rpt.number != '') {
                                var message = new APRSMessage();

                                message.callsign = instance.callsign;
                                message.destination = 'APZ678'; // we could send a mic-e packet to avoid having to send an experimental versioning
                                message.addressee = rpt.callsign;
                                message.message = 'ack' + rpt.number;
                                message.messageType = ':';
                                
                                Send(message);
                            }
                            
                            /*
                            this.number = '';
                            this.addressee = '';
                            this.message = '';
                            this.groupName = '';
                            */
                            
							
                            
                            // if the current station (callsign) is the addressee and there is an identifier and the message.number is populated
                            //      send an ack response: header + :{ + message.number
						}
					} catch(e) {
						//console.log('Parse Error: ' + e);
					}
				} else if(packets[x].indexOf("# javAPRSSrvr") == 0 || packets[x].indexOf("# aprsc") == 0) {
					console.log('received: ' + packets[x]);
					instance.SendLogin(instance);
					
				}
			}
		});
        
        instance.socket.on('error', function(data) {
            console.log('SOCKET ERROR!!!');
            console.log(data);
        });
        
        instance.socket.on('drain', function(data) {
            console.log('SOCKET Drained');
            console.log(data);
        });
	} catch(e) {
		throw e;
	}
};

JavAPRSISConnection.prototype.SendLogin = function() {
    var instance = this;
    
	try {
        if(instance.isEnabled) {
            //'user <callsign> pass <passcode> vers <softwareName> <softwareVersion> filter <filter>' + MESSAGE_DELIMITER

            var serverLogin = 'user ' + instance.callsign;
            serverLogin += ' pass ' + instance.passcode;

            serverLogin += ' vers ' + instance.softwareName;

            if(instance.softwareVersion !== null && instance.softwareVersion != undefined && instance.softwareVersion !== '') {
                serverLogin += ' ' + instance.softwareVersion;
            }

            if(instance.filter != null && instance.filter != '') {
                serverLogin += ' filter ' + instance.filter;
            }

            serverLogin += MESSAGE_DELIMITER;

            instance.emit('sending', serverLogin);

            instance.socket.write(serverLogin, 'utf8');

            if(instance.keepAliveTime != null && instance.keepAliveTime != undefined && instance.keepAliveTime > 0) {
                clearInterval(instance.keepAlive);
                instance.keepAlive = setInterval(instance.SendLogin, instance.keepAliveTime, instance);
            }
        }
	} catch(e) {
		console.log(e);
		instance.emit('exception', e);
	}
};

JavAPRSISConnection.prototype.Send = Send;

function Send(message) {
    var instance = this;
    
    try {
        console.log('send message');
        console.log(instance);
        
        if(instance.isTransmitEnabled) {
            var parser = new APRSPacketParser();

            var msg = instance.packetConverter.ToOutputFormat(message);
            var rpt = parser.parse(msg);
            
            console.log('Sending packet: ' + msg);
            
            if(message.ofType(APRSPositionReport)) {
                console.log('Sending position packet: ' + msg);

                instance.emit('position', rpt);
            } else if(message.ofType(APRSMessage)) {
                console.log('Sending Message: ' + msg);

                instance.emit('message', rpt);
            }
            
            instance.socket.write((msg + MESSAGE_DELIMITER), 'utf8');
        }
    } catch(e) {
        console.log(e);
        instance.emit('exception', e);
    }
};

module.exports = JavAPRSISConnection;