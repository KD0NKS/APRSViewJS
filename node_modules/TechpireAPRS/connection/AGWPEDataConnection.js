/*
 * THIS IS ADAPTED FROM AGWPEPORT
 * Andrew Fairhurst - KD0NKS
 *
 * Copyright 2008 William U. Walker
 * http://www.codeplex.com/AgwpePort
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

var util = require('util')
	, net = require('net')
	, EventEmitter = require('events').EventEmitter
	, AbstractDataConnection = require('./AbstractDataConnection.js')
	, AbstractPacketParser = require('../util/packets/AbstractPacketParser.js')
	, AGWPEPacketParser = require('../util/packets/AGWPEPacketParser.js')
    , AbstractAPRSMessage = require('../packets/AbstractAPRSMessage.js')
	;

var MESSAGE_DELIMITER = '\r\n';

var self = null;

function AGWPEDataConnection(args) {
	self = this;
	
	// TODO: Set defaults
	if(!args) {
		return;
	}
	
	self.callsign = args['callsign'];
	self.radioPort = args['radioPort'];
	
	/*
	this.passcode = args['passcode'];
	this.filter = args['filter'];
	
	// RESETTING AN INTERVAL EVERY TIME A MESSAGE IS RECEIVED IS EXTREMELY INEFFICIENT.  COME UP WITH SOMETHING BETTER.
	this.keepAliveTime = null;
	
	if(args['keepAliveTime'] != null && args['keepAliveTime'] != undefined && args['keepAliveTime'] > 0) {
		this.keepAliveTime = args['keepAliveTime'];
		this.keepAlive = setInterval(this.SendLogin, this.keepAliveTime, self);
	}
	*/
	
	AbstractDataConnection.apply(self, arguments);
	
	return self;
}

AGWPEDataConnection.prototype = new AbstractDataConnection();
AGWPEDataConnection.prototype.constructor = AGWPEDataConnection;

// http://phrogz.net/JS/classes/OOPinJS2.html
AGWPEDataConnection.prototype.parent = AbstractDataConnection.prototype;



// This does not work exactly like the JavAPRSISConnection.  To actually get data from AGWPE you must 
// Monitor first by sending AGWPE a monitor packet.
AGWPEDataConnection.prototype.Read = function() {
    self.parent.Read.call(self);
    
	try {
		var parser = new AGWPEPacketParser();
		
		self.socket.on('data', function(data) {
			//console.log(data.toString('utf8'));
			
			// TODO: split the data and iterate over it
			
			// parse the packet
			try {
				//var rpt = parser.parse(packets[x]);
				
				var rpt = parser.parse(data);
				
				// finding the message type in a nested if statement seems to be faster than storing the message types in an array to reduce the code
				if(rpt.messageType == '>') {
					// status report
				} else if(rpt.messageType == "$GPGGA,") {
					// GPPA
				} else if(rpt.messageType == '`'
						|| rpt.messageType == '\'') {
					// mic-e
					//console.log(rpt);
					self.emit('position', rpt);
				} else if(rpt.messageType == '='
						|| rpt.messageType == '!'
						|| rpt.messageType == '@'
						|| rpt.messageType == '/') {
					// position report
					//console.log(rpt);
					self.emit('position', rpt);
				} else if(rpt.messageType == '_') {
					// positionless weather report
				} else if(rpt.messageType == 'T') {
					// telemetry data
				} else if(rpt.messageType == ')') {
					//")" Item - bodyBytes.Length > 18
				} else if(rpt.messageType == ';') {
					//";" Object - bodyBytes.Length > 29
					self.emit('object', rpt);
				} else if(rpt.messageType == '}') {
					//"}" Third-party traffic
				} else if(rpt.messageType == ':') {
					// message
					self.emit('message', rpt);
				}
			} catch(e) {
				console.log('Parse Error: ' + e);
				//throw e;
			}
		});

		/*
		try {
			var parser = new APRSPacketParser();
			
			this.socket.on('data', function(data) {
				console.log(e);
			});
		} catch(e) {
			console.log(e);
		}

		
		int dataByte;

		while (!endThread)
		{
			
			// Pause to allow the system to work on other waiting threads.
			Thread.Sleep(1);
		}
		// Close the NetworkStream.
		stream.Close();
		// Close the TcpClient.
		tcpClient.Close();
		stream = null;
		*/
	} catch(e) {
		throw e;
	}
};


/*
 * Enable monitoring of activity on all configured radio ports. Traffic is not filtered by any callsign.
 */
AGWPEDataConnection.prototype.Monitor = function(dataLength) {
	// 'k' monitors in raw ax.25 format
	if(dataLength != null && dataLength != undefined && dataLength > 0) {
		self.socket.write(new Buffer(self.GetAgwpeFrame('m', dataLength)));
	} else {
		self.socket.write(new Buffer(self.GetAgwpeFrame('m', 0)));
	}
	
	/*
	frame[AgwpeFrame.PORT] = radioPort;
	
	ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
	ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
	
	if(data.Length > 0) {
		data.CopyTo(frame, AgwpeFrame.DATASTART);
	}
	
	agwpeThreadObject.Write(frame);
	*/
};

/*
<summary>

</summary>
<param name="dataKind"></param>
<param name="dataLen"></param>
<returns></returns>
*/
AGWPEDataConnection.prototype.GetAgwpeFrame = function(dataKind, dataLength) {
	var frame = new Array(dataLength + 36);
	
	if(dataKind != null && dataKind != undefined && dataKind != '') {
		// Set the DataKind byte in the AGWPE frame.
		//frame[AgwpeFrame.DATAKIND] = dataKind;
		frame[4] = dataKind.charCodeAt(0);
		
		// Copy the four byte array containing the DataLen value to the AGWPE frame.
		var bytes = new Array(4);
		
		for(x = 3; x > -1; x--) {
			frame[x + dataLength] = dataLength & (255);
			dataLength = dataLength >> 8;
		}
		
		//BitConverter.GetBytes(dataLen).CopyTo(frame, AgwpeFrame.DATALEN);
	}
	
	return frame;
};

AGWPEDataConnection.prototype.Send = Send;

function Send(message) {
    console.log("From AGW data connection");
}

/*
// Methods
        /// <summary>
        /// Creates a new thread to connect to a AGWPE process running on host/port.
        /// </summary>
        public void Open()
        {
            if (thread == null)
            {
                agwpeThreadObject = new AgwpeThread(radioPort,agwpeHost,port,this);
                thread = new Thread(agwpeThreadObject.Monitor);
                thread.Start();
            }
        }

        /// <summary>
        /// Creates a new thread to connect to a AGWPE process running on host/port.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        public void Open(byte radioPort)
        {
            this.radioPort = radioPort;
            Open();
        }

        /// <summary>
        /// Creates a new thread to connect to a AGWPE process running on host/port.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="host">The hostname or IP address of the machine running AGWPE, default is "localhost".</param>
        public void Open(byte radioPort, string host)
        {
            this.radioPort = radioPort;
            agwpeHost = host;
            Open();
        }

        /// <summary>
        /// Creates a new thread to connect to a AGWPE process running on host/port.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="host">The hostname or IP address of the machine running AGWPE, default is "localhost".</param>
        /// <param name="port">The TCP port that AGWPE is listening on, default is port 8000.</param>
        public void Open(byte radioPort, string host, int port)
        {
            this.radioPort = radioPort;
            agwpeHost = host;
            this.port = port;
            Open();
        }

        /// <summary>
        /// Closes the connection and ends the thread used to talk to the AGWPE process.
        /// </summary>
        public void Close()
        {
            if (thread != null)
            {
                if (thread.IsAlive)
                {
                    // Send the stop request to the thread.
                    agwpeThreadObject.End();
                    // Give the thread 1 second to terminate.
                    thread.Join(1000);
                }
            }
            agwpeThreadObject = null;
            thread = null;
        }

        /// <summary>
        /// Checks to see if the connection thread and TCP connection are alive.
        /// </summary>
        /// <returns>Returns true if the thread and connection are alive.</returns>
        public bool IsOpen()
        {
            if (thread != null)
                if (thread.IsAlive)
                    return agwpeThreadObject.Connected();
            return false;
        }

        

        /// <summary>
        /// Converts the String array past in the via parameter to a single byte array containing data 
        /// from all elements of the original String array.
        /// </summary>
        /// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
        /// <returns>A single byte array containing data from all elements of the original String array.
        /// </returns>
        private byte[] GetViaChain(string[] via)
        {
            byte[] viaData;
            int viaCount = 0, offset = 0;

            for (int count = 0; count < via.Length ; count++)
            {
                // Remove leading and trailing white-space characters from each via String.
                via[count] = via[count].Trim();
                // If the via String still contains characters...
                if (via[count].Length > 0)
                    // Increment the valid via counter.
                    viaCount++;
            }
            if (viaCount > 0)
            {
                viaData = new byte[(viaCount * 10) + 1];
                viaData[0] = (byte)viaCount;
                for (int count = 0; count < via.Length; count++)
                {
                    if (via[count].Length > 0)
                    {
                        ASCIIEncoding.UTF8.GetBytes(via[count], 0, via[count].Length, viaData, (offset * 10) + 1);
                        offset++;
                    }
                }
                return viaData;
            }
            return null;
        }

        //----------------------------------------------------------------------------
        /// <summary>
        /// Sends login information to a AGWPE process running on a remote machine.
        /// </summary>
        /// <param name="userName">A Login name as configured in the WinSock Interface Security tab of AGWPE.</param>
        /// <param name="password">A Password as configured in the WinSock Interface Security tab of AGWPE.</param>
        public void AppLogin(string userName, string password)
        {
            byte[] frame = GetAgwpeFrame((byte)'P', 510);

            // Test to ensure the username and password do not exceed 255 bytes.

            // Copy the username and password characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(userName, 0, userName.Length, frame, AgwpeFrame.DATASTART);
            ASCIIEncoding.UTF8.GetBytes(password, 0, password.Length, frame, 291);

            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// An application needs to register at least one callsign with AGWPE as a pre-requisite to be able to send data thru an AX.25
        /// port or to sustain a connection and before any attempt to do so.
        /// An application could register almost anything as a callsign, for example: W5ZIO-1 or EOC
        /// </summary>
        /// <param name="callSign">An identifier for this station.</param>
        /// <returns>Returns true or false depending on the success of the registration.</returns>
        public void RegisterCallSign(string callSign)
        {
            byte[] frame = GetAgwpeFrame((byte)'X', 0);

            // Test to ensure the callsign does not exceed 10 bytes.

            // Copy the callsign characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(callSign, 0, callSign.Length, frame, AgwpeFrame.CALLFROM);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// This is the opposite function of RegisterCallSign, it means the callsign is no longer used by the
        /// application. From the moment the application becomes unregistered, all activity heard by AGWPE on the AX.25 
        /// ports directed to that callsign is ignored.
        /// </summary>
        /// <param name="callFrom">The identifier being unregistered.</param>
        public void UnRegisterCallSign(string callSign)
        {
            byte[] frame = GetAgwpeFrame((byte)'x', 0);

            // Test to ensure the callsign does not exceed 10 bytes.

            // Copy the callsign characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(callSign, 0, callSign.Length, frame, AgwpeFrame.CALLFROM);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Requests the major and minor version from the AGWPE process application.
        /// </summary>
        public void GetVersion()
        {
            agwpeThreadObject.Write(GetAgwpeFrame((byte)'R', 0));
        }

        /// <summary>
        /// Requests information about all currently defined radio ports.
        /// </summary>
        public void GetPortInfo()
        {
            agwpeThreadObject.Write(GetAgwpeFrame((byte)'G', 0));
        }

        /// <summary>
        /// Requests information about a specific radio port.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
        public void GetPortCapability(byte radioPort)
        {
            byte[] frame = GetAgwpeFrame((byte)'g', 0);

            // Copy the radioPort value to the frame.
            frame[AgwpeFrame.PORT] = radioPort;
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Requests the number of frames queued to be transmitted on a currently defined radio port for the connection specified
        /// by the callFrom and callTo parameters.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
        /// <param name="callFrom">An identifier for this station if this station initiated the connection, or the remote station otherwise.</param>
        /// <param name="callTo">The identifier of the remote packet station if the remote station initiated the connection, or this station otherwise.</param>
        public void GetConnectionFrames(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'Y', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Requests the total number of frames, queued by all connections, to be transmitted on a currently defined radio port.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
        public void GetOutstandingFrames(byte radioPort)
        {
            byte[] frame = GetAgwpeFrame((byte)'y', 0);

            // Copy the radioPort value to the frame.
            frame[AgwpeFrame.PORT] = radioPort;
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Requests the last 20 stations heard by AGWPE. THe stations heard will be returned by 20 different AGWPE frames,
        /// each containing one station heard or default information if less than 20 stations have been heard. 
        /// These 20 stations are stored in AGWPE, so each time AGWPE is started the list starts over with 0 stations heard.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port the station list is being requested for.</param>
        public void StationsHeard(byte radioPort)
        {
            byte[] frame = GetAgwpeFrame((byte)'H', 0);

            // Copy the radioPort value to the frame.
            frame[AgwpeFrame.PORT] = radioPort;
            agwpeThreadObject.Write(frame);
        }
		
        /// <summary>
        /// Used to send AX.25 unproto (UI) frames. No callsign registration is required before using this method.
        /// This method is used for APRS, beacons, message broadcasts, NETROM L3 broadcasts, 
        /// TCP/IP over AX.25, FBB mail, etc.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        public void SendUnproto(byte radioPort, string callFrom, string callTo, byte[] data)
        {
            byte[] frame;

            if(data != null & data.Length > 0)
                frame = GetAgwpeFrame((byte)'M', (uint)data.Length);
            else
                frame = GetAgwpeFrame((byte)'M', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            if(data.Length > 0)
                data.CopyTo(frame, AgwpeFrame.DATASTART);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send AX.25 unproto (UI) frames. No callsign registration is required before using this method.
        /// This method is used for APRS, beacons, message broadcasts, NETROM L3 broadcasts, 
        /// TCP/IP over AX.25, FBB mail, etc.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        /// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
        public void SendUnproto(byte radioPort, string callFrom, string callTo, byte[] data, string[] via)
        {
            byte[] frame;
            byte[] viaChain;

            viaChain = GetViaChain(via);
            if (viaChain != null)
            {
                if (data != null & data.Length > 0)
                    frame = GetAgwpeFrame((byte)'V', (uint)viaChain.Length + (uint)data.Length);
                else
                    frame = GetAgwpeFrame((byte)'V', (uint)viaChain.Length);

                frame[AgwpeFrame.PORT] = radioPort;
                ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
                ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
                viaChain.CopyTo(frame, AgwpeFrame.DATASTART);
                if (data.Length > 0)
                    data.CopyTo(frame, AgwpeFrame.DATASTART + viaChain.Length);
                agwpeThreadObject.Write(frame);
            }
            else
                SendUnproto(radioPort, callFrom, callTo, data);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'C', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo, string[] via)
        {
            byte[] frame;
            byte[] viaChain;

            viaChain = GetViaChain(via);
            if (viaChain != null)
            {
                frame = GetAgwpeFrame((byte)'v', (uint)viaChain.Length);

                frame[AgwpeFrame.PORT] = radioPort;
                frame[AgwpeFrame.PID] = 0xF0;
                ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
                ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
                viaChain.CopyTo(frame, AgwpeFrame.DATASTART);
                agwpeThreadObject.Write(frame);
            }
            else
                AX25Connect(radioPort, callFrom, callTo);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="pid">The non-standard AX.25 PID to be used for this connection. AX.25 data frames must use the same PID.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo, byte pid)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'c', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = pid;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send data over an established AX.25 connection.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        public void SendAX25Data(byte radioPort, string callFrom, string callTo, byte[] data)
        {
            byte[] frame;

            if (data != null & data.Length > 0)
                frame = GetAgwpeFrame((byte)'D', (uint)data.Length);
            else
                frame = GetAgwpeFrame((byte)'D', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            if (data.Length > 0)
                data.CopyTo(frame, AgwpeFrame.DATASTART);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send data over an established AX.25 connection.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        /// <param name="pid">The non-standard AX.25 PID to be used for this connection. The AX.25 connection frame must use the same PID.</param>
        public void SendAX25Data(byte radioPort, string callFrom, string callTo, byte[] data, byte pid)
        {
            byte[] frame;

            if (data != null & data.Length > 0)
                frame = GetAgwpeFrame((byte)'D', (uint)data.Length);
            else
                frame = GetAgwpeFrame((byte)'D', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = pid;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            if (data.Length > 0)
                data.CopyTo(frame, AgwpeFrame.DATASTART);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE to disconnect an AX.25 connection with another station.
        /// If a disconnection request is sent without a connection first being established, AGWPE will ignore the request.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio used by the established connection.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        public void AX25Disconnect(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'d', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }



        public bool Connected()
        {
            if (tcpClient != null)
                return tcpClient.Connected;
            else
                return false;
        }
        
        public bool DataAvailable()
        { 
            return stream.DataAvailable; 
        } 
        
        public void Write(byte[] buffer)
        {
            if (stream != null)
            {
                stream.Write(buffer, 0, buffer.Length);
            }
        }

        public void WriteByte(byte value)
        {
            if (stream != null)
                stream.WriteByte(value);
        }

        public int Read(byte[] buffer, int offset, int size)
        {
            return dataBuffer.GetBytes(buffer, offset, size);
        }

        public byte ReadByte()
        {
            return dataBuffer.GetByte();
        }

        public void End()
        {
            endThread = true;
        }

*/

module.exports = AGWPEDataConnection;