/*
 * THIS IS ADAPTED FROM AGWPEPORT
 * Andrew Fairhurst - KD0NKS
 *
 * Copyright 2008 William U. Walker
 * http://www.codeplex.com/AgwpePort
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

var util = require('util')
	, net = require('net')
	, EventEmitter = require('events').EventEmitter
	, AbstractDataConnection = require('./AbstractDataConnection.js')
	, AbstractPacketParser = require('../util/packets/AbstractPacketParser.js')
    , AGWPEPacketConverter = require('../util/packets/AGWPEPacketConverter.js')
	, AGWPEPacketParser = require('../util/packets/AGWPEPacketParser.js')
    , AbstractAPRSMessage = require('../packets/AbstractAPRSMessage.js')
    , APRSMessage = require('../packets/APRSMessage.js')
    , APRSPositionReport = require('../packets/APRSPositionReport.js')
	;

var MESSAGE_DELIMITER = '\r\n';

var self = null;

function AGWPEDataConnection(args) {
    self = this;
    
    self.packetConverter = new AGWPEPacketConverter();
    
    self.PORT = 0;
    self.DATAKIND = 4;
    self.PID = 6;
    self.CALLFROM = 8;
    self.CALLTO = 18;
    self.DATALEN = 28;
    self.DATASTART = 36;

    
	
	// TODO: Set defaults
	if(!args) {
		return;
	}
	
	self.radioPort = args.radioPort;
	
	/*
	this.passcode = args['passcode'];
	this.filter = args['filter'];
	
	// RESETTING AN INTERVAL EVERY TIME A MESSAGE IS RECEIVED IS EXTREMELY INEFFICIENT.  COME UP WITH SOMETHING BETTER.
	this.keepAliveTime = null;
	
	if(args['keepAliveTime'] != null && args['keepAliveTime'] != undefined && args['keepAliveTime'] > 0) {
		this.keepAliveTime = args['keepAliveTime'];
		this.keepAlive = setInterval(this.SendLogin, this.keepAliveTime, self);
	}
	*/
	
	AbstractDataConnection.apply(self, arguments);
	
	return self;
}

AGWPEDataConnection.prototype = new AbstractDataConnection();
AGWPEDataConnection.prototype.constructor = AGWPEDataConnection;

// http://phrogz.net/JS/classes/OOPinJS2.html
AGWPEDataConnection.prototype.parent = AbstractDataConnection.prototype;



// This does not work exactly like the JavAPRSISConnection.  To actually get data from AGWPE you must 
// Monitor first by sending AGWPE a monitor packet.
AGWPEDataConnection.prototype.Read = function() {
    console.log('reading at connection');
    
    self.parent.Read.call(self);
    
	try {
		var parser = new AGWPEPacketParser();
		
		self.socket.on('data', function(data) {
			//console.log(data.toString('utf8'));
			
			// TODO: split the data and iterate over it
			
			// parse the packet
			try {
				//var rpt = parser.parse(packets[x]);
				
				var rpt = parser.parse(data);
				
				// finding the message type in a nested if statement seems to be faster than storing the message types in an array to reduce the code
				if(rpt.messageType == '>') {
					// status report
				} else if(rpt.messageType == "$GPGGA,") {
					// GPPA
				} else if(rpt.messageType == '`'
						|| rpt.messageType == '\'') {
					// mic-e
					//console.log(rpt);
					self.emit('position', rpt);
				} else if(rpt.messageType == '='
						|| rpt.messageType == '!'
						|| rpt.messageType == '@'
						|| rpt.messageType == '/') {
					// position report
					//console.log(rpt);
					self.emit('position', rpt);
				} else if(rpt.messageType == '_') {
					// positionless weather report
				} else if(rpt.messageType == 'T') {
					// telemetry data
				} else if(rpt.messageType == ')') {
					//")" Item - bodyBytes.Length > 18
				} else if(rpt.messageType == ';') {
					//";" Object - bodyBytes.Length > 29
					self.emit('object', rpt);
				} else if(rpt.messageType == '}') {
					//"}" Third-party traffic
				} else if(rpt.messageType == ':') {
					// message
					self.emit('message', rpt);
                    
                    // TODO: ACK THIS
                    if(rpt.addressee.toUpperCase() == self.callsign.toUpperCase() && rpt.number != '') {
                        var message = new APRSMessage();
                        
                        message.messageType = ':';
                        message.callsign = self.callsign.trim();
                        message.destination = 'APZ678'; // we could send a mic-e packet to avoid having to send an experimental versioning
                        message.addressee = rpt.callsign.trim();
                        message.message = 'ack' + rpt.number.trim();
                        
                        Send(message);
                    }
				} else {
                    console.log(data);
                }
			} catch(e) {
                // this also traps data such as port info for now
                console.log(data);
                console.log(unescape(encodeURIComponent(data)));
				console.log('Parse Error: ' + e);
                console.log(e);
				//throw e;
			}
		});

		/*
		try {
			var parser = new APRSPacketParser();
			
			this.socket.on('data', function(data) {
				console.log(e);
			});
		} catch(e) {
			console.log(e);
		}

		
		int dataByte;

		while (!endThread)
		{
			
			// Pause to allow the system to work on other waiting threads.
			Thread.Sleep(1);
		}
		// Close the NetworkStream.
		stream.Close();
		// Close the TcpClient.
		tcpClient.Close();
		stream = null;
		*/
	} catch(e) {
		throw e;
	}
};


/*
 * Enable monitoring of activity on all configured radio ports. Traffic is not filtered by any callsign.
 */
AGWPEDataConnection.prototype.Monitor = function(dataLength) {
    console.log('monitoring at connection');
    
	// 'k' monitors in raw ax.25 format
	if(dataLength != null && dataLength != undefined && dataLength > 0) {
		self.socket.write(new Buffer(self.GetAgwpeFrame('m', dataLength)));
	} else {
		self.socket.write(new Buffer(self.GetAgwpeFrame('m', 0)));
	}
	
	/*
	frame[AgwpeFrame.PORT] = radioPort;
	
	ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
	ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
	
	if(data.Length > 0) {
		data.CopyTo(frame, AgwpeFrame.DATASTART);
	}
	
	agwpeThreadObject.Write(frame);
	*/
};

/*
<summary>

</summary>
<param name="dataKind"></param>
<param name="dataLen"></param>
<returns></returns>
*/
AGWPEDataConnection.prototype.GetAgwpeFrame = function(dataKind, dataLength) {
	var frame = new Buffer(dataLength + 36);
    frame.fill(0);
	
	if(dataKind != null && dataKind != undefined && dataKind != '') {
		// Set the DataKind byte in the AGWPE frame.
		//frame[AgwpeFrame.DATAKIND] = dataKind;
		frame[self.DATAKIND] = dataKind.charCodeAt(0);
		
		// Copy the four byte array containing the DataLen value to the AGWPE frame.
		var dataLenBytes = new Buffer(4);
        dataLenBytes.fill(0);
		dataLenBytes.writeUInt32LE(dataLength);
        
        dataLenBytes.copy(frame, self.DATALEN, 0, dataLenBytes.length);
	}
	
	return frame;
};

/// <summary>
/// Converts the String array past in the via parameter to a single byte array containing data 
/// from all elements of the original String array.
/// </summary>
/// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
/// <returns>A single byte array containing data from all elements of the original String array.
/// </returns>
/// byte[]
function GetViaChain(via) {
    // byte[] viaData;
    var viaData = null;
    
    var viaCount = 0;
    var offset = 0;
    
    for(var count = 0; count < via.length ; count++) {
        // Remove leading and trailing white-space characters from each via String.
        via[count] = via[count].trim();
        
        // If the via String still contains characters...
        if((via[count]).length > 0) {
            // Increment the valid via counter.
            viaCount += 1;
        }
    }
    
    if (viaCount > 0) {
        viaData = new Buffer((viaCount * 10) + 1);
        viaData.fill(' ');
        
        // write the length of the digipeater path to viaData
        var viaLen = new Buffer(1);
        viaLen.fill(' ');
		viaLen.writeUInt8(viaCount);
        
        viaLen.copy(viaData, 0, 0, viaLen.length);
        
        // Add each digi to the chain
        for(var count = 0; count < via.length; count++) {
            if(via[count].length > 0) {
                var digiBuff = new Buffer(via[count]);
                
                digiBuff.copy(viaData, (offset * 10) + 1, 0, digiBuff.length);
                offset++;
            }
        }
        
        return viaData;
    }
    
    return new Buffer(0);
};

AGWPEDataConnection.prototype.Send = Send;

function Send(message) {
    if(self.isTransmitEnabled) {
        var sendPkt = null;
        
        if(message instanceof APRSPositionReport) {
            sendPkt = self.SendUnproto(null, message);
        } else if(message instanceof APRSMessage) {
            sendPkt = self.SendUnproto(null, message);
        }
        
        if(sendPkt != null && sendPkt.length > 0) {
            console.log('Sending: ' + sendPkt.toString('utf8'));
            
            self.socket.write(sendPkt);
        }
    }
}

/**
 * COMMUNICATION METHODS
 */
/// <summary>
/// Used to send AX.25 unproto (UI) frames. No callsign registration is required before using this method.
/// This method is used for APRS, beacons, message broadcasts, NETROM L3 broadcasts, 
/// TCP/IP over AX.25, FBB mail, etc.
/// </summary>
/// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
/// <param name="callFrom">An identifier for this station.</param>
/// <param name="callTo">The identifier of the remote packet station.</param>
/// <param name="data">A byte array of data to be sent.</param>
/// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
//AGWPEDataConnection.prototype.SendUnproto = function(byte radioPort, string callFrom, string callTo, byte[] data, string[] via) {
//AGWPEDataConnection.prototype.SendUnproto = function(radioPort, callFrom, callTo, data, via) {
AGWPEDataConnection.prototype.SendUnproto = function(radioPort, packet) {
    var frame = null;
    var digiBytes = null;
    var data = self.packetConverter.ToOutputFormat(packet);
    
    /*
     * A packet with no path gets no hops
     */
    if(packet.digipeaters != null && packet.digipeaters.length > 0) {
        digiBytes = GetViaChain(packet.digipeaters);
        
        if (data != null & data.length > 0) {
            frame = new Buffer(self.GetAgwpeFrame('V', (digiBytes.length + data.length)));
        } else {
            frame = new Buffer(self.GetAgwpeFrame('V', digiBytes.length));
        }

        frame[self.PORT] = self.radioPort;
        
        var callFrom = new Buffer(packet.callsign);
        var callTo = new Buffer(packet.destination);
                               
        // copy the callsign into the frame starting at the callfrom index
        callFrom.copy(frame, self.CALLFROM, 0, callFrom.length);
        
        // copy the destination into the frame starting at the callto index
        callTo.copy(frame, self.CALLTO, 0, callTo.length);
        
        digiBytes.copy(frame, self.DATASTART, 0, digiBytes.length);
        
        if(data != null && data.length > 0) {
            data.copy(frame, (self.DATASTART + digiBytes.length), 0, data.length);
        }
    } else {
        if(data != null && data.length > 0) {
            frame = new Buffer(self.GetAgwpeFrame('M', data.length ));
        } else {
            frame = new Buffer(self.GetAgwpeFrame('M', 0));
        }
        
        frame[self.PORT] = self.radioPort;
        
        var callFrom = new Buffer(packet.callsign);
        var callTo = new Buffer(packet.destination);
        
        // copy the callsign into the frame starting at the callfrom index
        callFrom.copy(frame, self.CALLFROM, 0, callFrom.length);
        
        // copy the destination into the frame starting at the callto index
        callTo.copy(frame, self.CALLTO, 0, callTo.length);
        
        // copy the data into the frame at the datastart index
        if(data != null && data.length > 0) {
            data.copy(frame, self.DATASTART, 0, data.length);
        }
    }
    
    return frame;
}

/**
 * INFO UTILITY METHODS
 */

/// <summary>
/// Requests the major and minor version from the AGWPE process application.
/// </summary>
AGWPEDataConnection.prototype.GetVersion = function() {
    self.socket.write(new Buffer(self.GetAgwpeFrame('R', 0)));
}

/// <summary>
/// Requests information about all currently defined radio ports.
/// </summary>
AGWPEDataConnection.prototype.GetPortInfo = function() {
    self.socket.write(new Buffer(self.GetAgwpeFrame('G', 0)));
}

/// <summary>
/// Requests information about a specific radio port.
/// </summary>
/// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
AGWPEDataConnection.prototype.GetPortCapability = function() { // radio port is a byte
    self.socket.write(new Buffer(self.GetAgwpeFrame('g', 0)));
}

/// <summary>
/// Requests the total number of frames, queued by all connections, to be transmitted on a currently defined radio port.
/// </summary>
/// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
AGWPEDataConnection.prototype.GetOutstandingFrames = function() {
    var frame = new Buffer(self.GetAgwpeFrame('y', 0))

    // Copy the radioPort value to the frame.
    frame[self.PORT] = self.radioPort;
    self.socket.write(frame);
}

/// <summary>
/// Requests the last 20 stations heard by AGWPE. THe stations heard will be returned by 20 different AGWPE frames,
/// each containing one station heard or default information if less than 20 stations have been heard. 
/// These 20 stations are stored in AGWPE, so each time AGWPE is started the list starts over with 0 stations heard.
/// </summary>
/// <param name="radioPort">The AGWPE configured radio port the station list is being requested for.</param>
AGWPEDataConnection.prototype.StationsHeard = function() {
    var frame = new Buffer(self.GetAgwpeFrame('H', 0));

    // Copy the radioPort value to the frame.
    frame[self.PORT] = self.radioPort;
    self.socket.write(frame);
}








/*
// Methods
        /// <summary>
        /// Closes the connection and ends the thread used to talk to the AGWPE process.
        /// </summary>
        public void Close()
        {
            if (thread != null)
            {
                if (thread.IsAlive)
                {
                    // Send the stop request to the thread.
                    agwpeThreadObject.End();
                    // Give the thread 1 second to terminate.
                    thread.Join(1000);
                }
            }
            agwpeThreadObject = null;
            thread = null;
        }

        /// <summary>
        /// Checks to see if the connection thread and TCP connection are alive.
        /// </summary>
        /// <returns>Returns true if the thread and connection are alive.</returns>
        public bool IsOpen()
        {
            if (thread != null)
                if (thread.IsAlive)
                    return agwpeThreadObject.Connected();
            return false;
        }

        //----------------------------------------------------------------------------
        /// <summary>
        /// Sends login information to a AGWPE process running on a remote machine.
        /// </summary>
        /// <param name="userName">A Login name as configured in the WinSock Interface Security tab of AGWPE.</param>
        /// <param name="password">A Password as configured in the WinSock Interface Security tab of AGWPE.</param>
        public void AppLogin(string userName, string password)
        {
            byte[] frame = GetAgwpeFrame((byte)'P', 510);

            // Test to ensure the username and password do not exceed 255 bytes.

            // Copy the username and password characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(userName, 0, userName.Length, frame, AgwpeFrame.DATASTART);
            ASCIIEncoding.UTF8.GetBytes(password, 0, password.Length, frame, 291);

            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// An application needs to register at least one callsign with AGWPE as a pre-requisite to be able to send data thru an AX.25
        /// port or to sustain a connection and before any attempt to do so.
        /// An application could register almost anything as a callsign, for example: W5ZIO-1 or EOC
        /// </summary>
        /// <param name="callSign">An identifier for this station.</param>
        /// <returns>Returns true or false depending on the success of the registration.</returns>
        public void RegisterCallSign(string callSign)
        {
            byte[] frame = GetAgwpeFrame((byte)'X', 0);

            // Test to ensure the callsign does not exceed 10 bytes.

            // Copy the callsign characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(callSign, 0, callSign.Length, frame, AgwpeFrame.CALLFROM);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// This is the opposite function of RegisterCallSign, it means the callsign is no longer used by the
        /// application. From the moment the application becomes unregistered, all activity heard by AGWPE on the AX.25 
        /// ports directed to that callsign is ignored.
        /// </summary>
        /// <param name="callFrom">The identifier being unregistered.</param>
        public void UnRegisterCallSign(string callSign)
        {
            byte[] frame = GetAgwpeFrame((byte)'x', 0);

            // Test to ensure the callsign does not exceed 10 bytes.

            // Copy the callsign characters to the frame as bytes.
            ASCIIEncoding.UTF8.GetBytes(callSign, 0, callSign.Length, frame, AgwpeFrame.CALLFROM);
            agwpeThreadObject.Write(frame);
        }

        

        /// <summary>
        /// Requests the number of frames queued to be transmitted on a currently defined radio port for the connection specified
        /// by the callFrom and callTo parameters.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port information is being requested for.</param>
        /// <param name="callFrom">An identifier for this station if this station initiated the connection, or the remote station otherwise.</param>
        /// <param name="callTo">The identifier of the remote packet station if the remote station initiated the connection, or this station otherwise.</param>
        public void GetConnectionFrames(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'Y', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        
		
        

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'C', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="via">A String array containing a list of relay stations, one in each element of the array.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo, string[] via)
        {
            byte[] frame;
            byte[] viaChain;

            viaChain = GetViaChain(via);
            if (viaChain != null)
            {
                frame = GetAgwpeFrame((byte)'v', (uint)viaChain.Length);

                frame[AgwpeFrame.PORT] = radioPort;
                frame[AgwpeFrame.PID] = 0xF0;
                ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
                ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
                viaChain.CopyTo(frame, AgwpeFrame.DATASTART);
                agwpeThreadObject.Write(frame);
            }
            else
                AX25Connect(radioPort, callFrom, callTo);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE when an AX.25 connection with another station is required.
        /// The station originating the connection (CallFrom) must have been previously registered with AGWPE for the
        /// connection to be successfully established.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending and receiving packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="pid">The non-standard AX.25 PID to be used for this connection. AX.25 data frames must use the same PID.</param>
        public void AX25Connect(byte radioPort, string callFrom, string callTo, byte pid)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'c', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = pid;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send data over an established AX.25 connection.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        public void SendAX25Data(byte radioPort, string callFrom, string callTo, byte[] data)
        {
            byte[] frame;

            if (data != null & data.Length > 0)
                frame = GetAgwpeFrame((byte)'D', (uint)data.Length);
            else
                frame = GetAgwpeFrame((byte)'D', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            if (data.Length > 0)
                data.CopyTo(frame, AgwpeFrame.DATASTART);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send data over an established AX.25 connection.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio port to use for sending packet data.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        /// <param name="data">A byte array of data to be sent.</param>
        /// <param name="pid">The non-standard AX.25 PID to be used for this connection. The AX.25 connection frame must use the same PID.</param>
        public void SendAX25Data(byte radioPort, string callFrom, string callTo, byte[] data, byte pid)
        {
            byte[] frame;

            if (data != null & data.Length > 0)
                frame = GetAgwpeFrame((byte)'D', (uint)data.Length);
            else
                frame = GetAgwpeFrame((byte)'D', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = pid;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            if (data.Length > 0)
                data.CopyTo(frame, AgwpeFrame.DATASTART);
            agwpeThreadObject.Write(frame);
        }

        /// <summary>
        /// Used to send port and callsign information to AGWPE to disconnect an AX.25 connection with another station.
        /// If a disconnection request is sent without a connection first being established, AGWPE will ignore the request.
        /// </summary>
        /// <param name="radioPort">The AGWPE configured radio used by the established connection.</param>
        /// <param name="callFrom">An identifier for this station.</param>
        /// <param name="callTo">The identifier of the remote packet station.</param>
        public void AX25Disconnect(byte radioPort, string callFrom, string callTo)
        {
            byte[] frame;

            frame = GetAgwpeFrame((byte)'d', 0);

            frame[AgwpeFrame.PORT] = radioPort;
            frame[AgwpeFrame.PID] = 0xF0;
            ASCIIEncoding.UTF8.GetBytes(callFrom, 0, callFrom.Length, frame, AgwpeFrame.CALLFROM);
            ASCIIEncoding.UTF8.GetBytes(callTo, 0, callTo.Length, frame, AgwpeFrame.CALLTO);
            agwpeThreadObject.Write(frame);
        }
*/

module.exports = AGWPEDataConnection;